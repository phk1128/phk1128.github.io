---
title: 3-way handshake & 4-way handshake
date: 2024-09-11
categories: [ CS, Network ]
tags: [ 네트워크, network, CS, 3-way handshake, 4-way handshake ]
image: assets/posts/img_12.png
---

## 🎬 Intro
> 3-way handshake & 4-way handshake에 대해 알아봅시다.

### ✅ 3-way handshake
![img.png](/assets/posts/img_19.png)

3-Way Handshake는 클라이언트가 서버와 연결을 설정하기 위해 사용하는 과정입니다. 이 과정은 연결을 안정적으로 설정하고, 데이터 전송을 시작하기 전에 통신 경로를 확인하는 단계입니다.

- SYN (Synchronization): 연결 요청을 나타내며, 클라이언트가 서버에 세션을 설정하기 위해 초기 시퀀스 번호를 전송합니다.
- ACK (Acknowledgement): 서버가 클라이언트의 시퀀스 번호에 1을 더한 ACK를 반환하여 요청을 확인합니다.


#### Step 1: 클라이언트가 서버로 SYN 전송

- 클라이언트는 서버와의 연결을 설정하기 위해 SYN 패킷을 전송합니다. 이 패킷에는 클라이언트 측의 초기 시퀀스 번호가 포함됩니다.
- **초기 시퀀스 번호(ISN)** 난수로 지정됩니다.
  - 커넥션을 맺을 때 사용하는 포트는 유한한 범위 내에서 사용되며, 시간이 지나면 재사용될 수 있습니다.
    따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 다시 사용할 가능성이 존재합니다. 서버 측에서는 세그먼트의 SYN을 보고 세그먼트를 구분하는데, 만약 시퀀스 번호가 난수가 아닌 순차적인 번호로 전송된다면, 이전의 커넥션에서 온 세그먼트로 잘못 인식될 수 있습니다.
    이러한 문제를 방지하기 위해 **초기 시퀀스 번호(ISN)**는 난수로 설정됩니다.
  
  - 예를 들어, 이전 연결에서 사용된 ISN이 100이고, 현재 연결에서 사용된 ISN이 200이라고 가정하면,
    이전 연결의 데이터 세그먼트는 시퀀스 번호 100부터 시작할 것입니다. 반면에, 새로운 연결에서는 ISN이 200부터 시작하므로,
    서로 다른 시퀀스 번호로 인해 이전 연결의 데이터가 현재 연결로 잘못 전달되는 상황을 방지할 수 있습니다.

#### Step 2: 서버가 SYN + ACK 전송

- 서버는 클라이언트로부터 SYN 패킷을 수신한 후, 요청을 수락했음을 나타내는 **ACK 패킷**과 서버 측의 시퀀스 번호를 담은 **SYN 패킷**을 동시에 보냅니다.
- 서버도 클라이언트와 마찬가지로 난수를 시퀀스 번호로 설정합니다.
- 서버가 클라이언트에게 보내는 ACK는 클라이언트가 보낸 시퀀스 번호에 **+1**을 한 값을 반환합니다.

#### Step 3: 클라이언트가 ACK 전송

- 클라이언트는 서버로부터 SYN과 ACK 패킷을 받으면, 서버의 시퀀스 번호에 **+1**을 한 **ACK 패킷**을 서버로 전송합니다.
- 이 시점에서 **풀 듀플렉스(Full-Duplex)** 통신이 구축되며, 양방향 데이터 전송이 가능합니다.
- Full - duplex 통신의 구성
  - step 1,2 에서는 클라이언트 → 서버 방향에 대한 연결 파라미터를 설정 하고 이를 서버가 승인
  - step 2,3 에서는 서버 → 클라이언트 방향에 대한 연결 파라미터를 설정 하고 이를 클라이언트가 승인
  - 이를 통해 full-duplex 통신이 구축

---

![img.png](/assets/posts/img_20.png)

### ✅ 4-way handshake

**4-Way Handshake**는 TCP 연결 종료 과정을 나타냅니다. 연결을 종료할 때는 **FIN 플래그**가 사용되며, 클라이언트와 서버가 모두 데이터를 전송 완료했음을 확인하는 과정을 거칩니다.

- **FIN** (Finish): 더 이상 전송할 데이터가 없음을 나타내며, 연결을 종료하기 위한 요청입니다.

#### Step 1: 클라이언트 → 서버로 FIN 전송

- 클라이언트가 연결을 종료하려고 할 때 **FIN 패킷**을 전송합니다. 이 패킷은 클라이언트가 더 이상 보낼 데이터가 없음을 나타냅니다.

#### Step 2: 서버가 ACK 전송

- 서버는 FIN 패킷을 수신하고, 이에 대한 **ACK 패킷**을 클라이언트에게 전송합니다. ACK는 클라이언트가 보낸 시퀀스 번호에 **+1**을 더해 반환합니다.
- 서버는 아직 전송할 데이터가 남아 있을 수 있으므로, 클라이언트가 FIN을 보낸 후에도 연결을 유지합니다.

#### Step 3: 서버가 FIN 전송

- 서버는 모든 데이터를 전송한 후, **FIN 패킷**을 클라이언트로 전송합니다. 이는 서버 측에서 더 이상 보낼 데이터가 없음을 나타냅니다.

#### Step 4: 클라이언트가 ACK 전송

- 클라이언트는 서버의 FIN 패킷을 수신한 후 **ACK 패킷**을 전송합니다. 이로써 양쪽 모두 연결 종료를 확인하며, **TIME_WAIT** 상태에 진입하여 잠시 대기한 후 연결이 완전히 종료됩니다.

---

### ❓TCP 관련 질문

#### Q1: TCP 연결 설정(3단계)과 연결 종료(4단계) 과정이 단계가 다른 이유?
**답변**: 클라이언트가 데이터 전송을 종료했더라도 서버는 아직 보낼 데이터가 남아 있을 수 있습니다. 따라서 클라이언트가 FIN 패킷을 보내면 서버는 ACK 패킷으로 응답한 후, 데이터를 모두 전송한 다음에야 FIN 패킷을 보내게 됩니다. 이 때문에 연결 종료 과정은 4단계로 이루어집니다.

#### Q2: 서버에서 FIN 패킷보다 늦게 도착하는 패킷이 있을 경우?
**답변**: 이러한 상황에 대비해 클라이언트는 서버로부터 FIN 패킷을 수신하더라도 **TIME_WAIT** 상태에 들어갑니다. 이 기간 동안 잉여 패킷을 기다리며, 기본적으로 240초 동안 세션을 유지하고 패킷을 수신할 준비를 합니다. 이를 통해 지연된 패킷이 연결이 종료된 이후에도 안전하게 처리될 수 있도록 합니다.

#### Q3: 초기 시퀀스 번호(ISN)를 난수로 생성하는 이유?
**답변**: 포트 번호는 유한한 범위를 가지며, 시간이 지나면 재사용될 수 있습니다. 따라서 이전 연결에서 사용된 포트 번호와 시퀀스 번호가 새로운 연결과 중복될 가능성이 있습니다. 이를 방지하기 위해 초기 시퀀스 번호(ISN)를 난수로 설정하여 중복된 데이터 패킷이 잘못된 연결로 인식되는 것을 방지합니다.

---

## ✨ Summary
TCP의 **3-Way Handshake**는 안정적인 연결을 설정하기 위한 과정이며, **4-Way Handshake**는 안전하게 연결을 종료하기 위한 과정입니다. 각각의 단계에서 시퀀스 번호와 ACK 번호를 활용하여 데이터 전송의 신뢰성을 보장하며, 이를 통해 TCP는 신뢰성 있는 통신을 제공합니다.
